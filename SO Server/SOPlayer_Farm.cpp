#include "SOMain.h"
#include "SOWorld.h"
#include "SOPlayer.h"
#include "OnlineCommonStruct.h"

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	플레이어가 소유하고 있는 시설물을 얻어온다.
//	수정 일자	:	2002-10-04 오후 7:38:43 - 양정모
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
stFarmData*	SOPlayer::GetOwnFactory()
{
//	return pMyWorld->GetOwnFactory( stAccountInfo.siDBAccount, stAccountInfo.uiSlot );
	return	NULL;
}

//----------------------------------------------------------------------------------------------------------------
//	설명	:	농장의 정보를 얻어온다.
//----------------------------------------------------------------------------------------------------------------
VOID SOPlayer::RecvFarmInfo()
{
	BOOL	bSuccess = FALSE;

	if( IsInVillage() == FALSE )									goto	END;

	if( stAccountInfo.pVillage->DoesFactoryExist() == FALSE )		goto	END;
	
	bSuccess	=	stAccountInfo.pVillage->m_pIndustrialComplexs->SendIndustrialComplexList( this );					
	

END:
	
	if( bSuccess == FALSE )
	{
		SendFieldMsg( ON_RESPONSE_FARM_INFO, SO_SFM_ONLYME, LPVOID( -1 ) );
	}
}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	산업 단지를 구입한다.
//	수정 일자	:	2002-10-08 오후 8:29:14 - 양정모
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VOID SOPlayer::RecvFarmBuy()
{
	OnReqFarmBuyMsg			*pReqFarmBuyMsg;
	BOOL					bResult = FALSE;
	
	pReqFarmBuyMsg	=		(OnReqFarmBuyMsg*)cMsg;

	// 이미 구입한 산업 단지가 있는지 검사한다.
	if( pMyWorld->IsIndustrialComplexOwner( this ) == TRUE )				goto	END;

	if( IsInVillage() == FALSE )											goto	END;
		
	bResult	=	stAccountInfo.pVillage->m_pIndustrialComplexs->BuyIndustrialComplex( this, pReqFarmBuyMsg->uiFarmIndex);
	
END:

	if( bResult == FALSE )
	{
		SendFieldMsg( ON_RESPONSE_FARM_BUY, SO_SFM_ONLYME, LPVOID(ON_RET_NO) );
	}

	/*
	if(stAccountInfo.pVillage )
	{
		bResult	=	stAccountInfo.pVillage->BuyFarm( this, pReqFarmBuyMsg->uiPlantID, pReqFarmBuyMsg->uiFarmIndex);
	}
	if( bResult )
		SendFieldMsg( ON_RESPONSE_FARM_BUY, SO_SFM_ONLYME, LPVOID(ON_RET_OK) );
	else
	*/	
}

//----------------------------------------------------------------------------------------------------------------
//	설명	:	생산 건물을 팔아 버린다.
//----------------------------------------------------------------------------------------------------------------
VOID SOPlayer::RecvFarmSell()
{
	OnReqFarmBuyMsg			*pReqFarmBuyMsg;
	BOOL					bResult = FALSE;
	
	pReqFarmBuyMsg	=		(OnReqFarmBuyMsg*)cMsg;

	if(stAccountInfo.pVillage != NULL)
	{
		if( stAccountInfo.pVillage->DoesFactoryExist() == TRUE )
		{
			bResult	=	stAccountInfo.pVillage->m_pIndustrialComplexs->SellFactory( this, pReqFarmBuyMsg->uiFarmIndex );
		}

/*
		if(pReqFarmBuyMsg->uiFarmIndex >=0 && pReqFarmBuyMsg->uiFarmIndex <ON_VILLAGE_FARM_NUM )
		{
			bResult	=	stAccountInfo.pVillage->BuyFarm( this ,pReqFarmBuyMsg->uiPlantID, pReqFarmBuyMsg->uiFarmIndex);
			if( bResult	==	TRUE )
			{
				SendFieldMsg(ON_RESPONSE_FARM_BUY, SO_SFM_ONLYME, LPVOID(ON_RET_OK));
			}
		}
		*/
	}
	if( bResult == FALSE )
		SendFieldMsg(ON_RESPONSE_FARM_BUY, SO_SFM_ONLYME, LPVOID( ON_RET_NO ) );
}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	농장의 슬롯정보를 얻어온다.(농장에 들어가면서 농장 전경을 보여줄때...)
//	수정 일자	:	2002-10-10 오후 2:06:16 - 양정모
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VOID SOPlayer::RecvFarmSlotInfo()
{
	OnReqFarmSlotInfoMsg				*pFarmSlotinfoMsg;
	BOOL								bSuccess  = FALSE;

	pFarmSlotinfoMsg			=	(OnReqFarmSlotInfoMsg*)cMsg;
	if(stAccountInfo.pVillage)
	{

		bSuccess	=	stAccountInfo.pVillage->EnterStructure( this, ON_VIL_ST_KIND_FARM, 0, pFarmSlotinfoMsg->uiFarmIndex);
			
	}

	if( bSuccess == FALSE )
	{
		SendFieldMsg( ON_RESPONSE_FARM_SLOTINFO, SO_SFM_ONLYME, LPVOID( -1 ) );
	}

}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	농장의 건물을 짓는다.
//	수정 일자	:	2002-09-23 오후 3:13:52 - 양정모
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VOID	SOPlayer::RecvFarmBuildStruct()
{	
	OnReqFarmBuildStructMsg				*pFarmBuildStructMsg;
	BOOL								bSuccess = FALSE;	

	if( stAccountInfo.pVillage == NULL )	goto	END;

	pFarmBuildStructMsg		=	( OnReqFarmBuildStructMsg* ) cMsg;
	//dwResult				=	stAccountInfo.pVillage->BuildFarmStruct( this, pFarmBuildStructMsg->uiSlotIndex, 
	//																	pFarmBuildStructMsg->Code, pFarmBuildStructMsg->siPay );
	bSuccess				=	stAccountInfo.pVillage->ConstructFactory( this, pFarmBuildStructMsg->uiSlotIndex, pFarmBuildStructMsg->Code, pFarmBuildStructMsg->siPay );

END:

	if( bSuccess == FALSE )
	{

		SendFieldMsg( ON_RESPONSE_FARM_BUILDSTRUCT, SO_SFM_ONLYME, LPVOID( ON_RET_NO ) );

	}

}

//----------------------------------------------------------------------------------------------------------------
//	설명	:	농장의 슬롯을 확장한다.
//----------------------------------------------------------------------------------------------------------------
VOID	SOPlayer::RecvFarmUpgradeSlot()
{
	OnReqFarmUpgradeSlotMsg			*pUpgradeSlotMsg;
	BOOL							bSuccess = FALSE;	
	
	pUpgradeSlotMsg				=	(OnReqFarmUpgradeSlotMsg*)	cMsg;

	if( IsInVillage() == FALSE )		goto	END;

	bSuccess = stAccountInfo.pVillage->UpgradeSlot( this, pUpgradeSlotMsg->uiSlotIndex, pUpgradeSlotMsg->siPay );

END:

	if( bSuccess == FALSE )
	{

		SendFieldMsg( ON_RESPONSE_FARM_UPGRADESLOT, SO_SFM_ONLYME, LPVOID( ON_RET_NO ) );

	}

}
//----------------------------------------------------------------------------------------------------------------
//	설명	:	농장의 슬롯을 확장한다.
//----------------------------------------------------------------------------------------------------------------
VOID	SOPlayer::RecvFarmExpandSlot()
{
	OnReqFarmExpandSlotMsg			*pFarmExpandSlotMsg;
	BOOL							bSuccess  = FALSE;
	
	pFarmExpandSlotMsg		=		(OnReqFarmExpandSlotMsg*)cMsg;		

	if( IsInVillage() == TRUE )
	{	
		bSuccess	= stAccountInfo.pVillage->ExpandFarmSlot( this, pFarmExpandSlotMsg->uiPlantID, pFarmExpandSlotMsg->uiFarmIndex );
	}

	if( bSuccess == FALSE )
	{

		SendFieldMsg(ON_RESPONSE_FARM_EXPANDSLOT, SO_SFM_ONLYME, LPVOID(ON_RET_NO));
		
	}

}

//----------------------------------------------------------------------------------------------------------------
//	설명	:	농장 건물을 제거한다.
//----------------------------------------------------------------------------------------------------------------
VOID	SOPlayer::RecvFarmDestroyStruct()
{
	OnReqFarmDestroyStructMsg		*pFarmDestroyStructMsg;
	BOOL							bSuccess;
	
	pFarmDestroyStructMsg			=	(OnReqFarmDestroyStructMsg*)	cMsg;

	if( IsInVillage() == FALSE )			goto	END;
	
	bSuccess	=	stAccountInfo.pVillage->DestroyPlantSlot( this, pFarmDestroyStructMsg->uiSlotIndex );

		/*if(stAccountInfo.pVillage->DestroyPlantSlot(this, pFarmDestroyStructMsg->uiSlotIndex) == TRUE)
		{
			SendFieldMsg(ON_RESPONSE_FARM_DESTROYSTRUCT, SO_SFM_ONLYME, LPVOID(ON_RET_OK));
			return;
		}
		*/

END:

	if( bSuccess == FALSE )
	{

		SendFieldMsg( ON_RESPONSE_FARM_DESTROYSTRUCT, SO_SFM_ONLYME, LPVOID( ON_RET_NO ) );

	}

}

//----------------------------------------------------------------------------------------------------------------
//	설명	:	시설물을 설치 한다.(건물 업그레이드)
//----------------------------------------------------------------------------------------------------------------
VOID	SOPlayer::RecvFarmSetEquipment()
{
	OnReqFarmSetEquipmentMsg		*pFarmSetEquipmentMsg;
	
	if(stAccountInfo.pVillage != NULL)
	{
		pFarmSetEquipmentMsg		=	(OnReqFarmSetEquipmentMsg*) cMsg;
//		if(stAccountInfo.pVillage->SetFarmEquipment(this, pFarmSetEquipmentMsg->uiPlantID,
//		pFarmSetEquipmentMsg->uiFarmIndex, pFarmSetEquipmentMsg->uiSlotIndex,pFarmSetEquipmentMsg->uiUpIndex) == TRUE)
		{
			SendFieldMsg(ON_RESPONSE_FARM_SETEQUIPMENT, SO_SFM_ONLYME, LPVOID(ON_RET_OK));
			return;
		}
	}
	SendFieldMsg(ON_RESPONSE_FARM_SETEQUIPMENT, SO_SFM_ONLYME, LPVOID(ON_RET_NO));
};


//----------------------------------------------------------------------------------------------------------------
//	설명	:	아이템을 생산한다.(계획을 세운다.)
//----------------------------------------------------------------------------------------------------------------
VOID	SOPlayer::RecvFarmItemProduct()
{
	OnReqFarmItemProductMsg			*pFarmItemProductMsg;
	DWORD							dwResponse = ON_RET_NO;

	pFarmItemProductMsg		=	(OnReqFarmItemProductMsg*)cMsg;

	if( IsInVillage() == FALSE )			goto	END;	

	dwResponse		=	stAccountInfo.pVillage->ProductItem( this, pFarmItemProductMsg->uiPlantID, pFarmItemProductMsg->uiFarmIndex,
															pFarmItemProductMsg->uiSlotIndex, pFarmItemProductMsg->uiItemCode, 
															pFarmItemProductMsg->uiQuantity,pFarmItemProductMsg->uiPay);

END:

	if( dwResponse != ON_RET_OK )
	{
		SendFieldMsg( ON_RESPONSE_FARM_ITEMPRODUCT, SO_SFM_ONLYME, LPVOID( dwResponse ) );
	}	

}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	생산을 위한 일을 한다.
//	수정 일자	:	2002-10-11 오후 4:13:44 - 양정모
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VOID	SOPlayer::RecvFarmWorkStart()
{
	OnReqFarmWorkStartMsg			*pFarmWorkStartMsg;
	BOOL							bSuccess = FALSE;	

	if(stAccountInfo.pVillage != NULL)
	{
		pFarmWorkStartMsg		=	(OnReqFarmWorkStartMsg*) cMsg;
		
		//bSuccess				= stAccountInfo.pVillage->PlantWorkAble( this, pFarmWorkStartMsg->uiSlotIndex );
		bSuccess				= stAccountInfo.pVillage->PlantWorkAble( this );
	}

	if( bSuccess == FALSE )
	{

		SendFieldMsg( ON_RESPONSE_FARM_WORKSTART, SO_SFM_ONLYME, LPVOID( ON_RET_NO ) );

	}

}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	일을 끝마쳤다.
//	수정 일자	:	2002-07-22 오후 2:00:14 - 양정모
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VOID	SOPlayer::RecvFarmWork()
{
	OnReqFarmWorkMsg				*pFarmWorkMsg;
	stFarmSlot						*pFarmSlot = NULL;	
	
	BOOL							bSuccess	=	FALSE;

	pFarmWorkMsg		=	(OnReqFarmWorkMsg*) cMsg;

	if( IsInVillage() == FALSE )
	{
		goto	END;
	}
	
	if( stAccountInfo.pVillage->DoesFactoryExist() == FALSE )
	{
		goto	END;
	}

	bSuccess	=	stAccountInfo.pVillage->m_pIndustrialComplexs->FinishWork( this, pFarmWorkMsg );

	if( bSuccess == TRUE )
	{
		// 퀘스트에 일한 양을 알려준다.
		Quest_AddQuestObject_Work( pFarmWorkMsg->siLabor );
	}


END:
	if( bSuccess == FALSE )
	{
		SendFieldMsg( ON_RESPONSE_FARM_WORK, SO_SFM_ONLYME, LPVOID( ON_RET_NO ) );
	}

}


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	작업량 해킹 모니터링 로그
//	수정 일자	:	2003-07-21 오전 11:54 - 백상현
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VOID	SOPlayer::RecvFarmWorkHack()
{	
	OnFarmWorkHack*		pRecvMsg;

	pRecvMsg	=	(OnFarmWorkHack*)cMsg;

//	pMyWorld->clServer->WriteInfo( "..\\RecvFarmWorkHack.txt", "DBAccount(%d)  szID(%s)  uiType(%d)  siStep(%d)  siPoint1(%d)  siPoint2(%d)",
//									stAccountInfo.siDBAccount, szID, pRecvMsg->uiType, pRecvMsg->siStep, pRecvMsg->siPoint1, pRecvMsg->siPoint2 );
	writeInfoToFile( "RecvFarmWorkHack.txt", "DBAccount(%d)  szID(%s)  uiType(%d)  siStep(%d)  siPoint1(%d)  siPoint2(%d)",
									stAccountInfo.siDBAccount, szID, pRecvMsg->uiType, pRecvMsg->siStep, pRecvMsg->siPoint1, pRecvMsg->siPoint2 );

}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	작업량을 체크하여 정상이면 TRUE, 해킹의 우려가 있으면 FALSE.. 하드코딩의 진수 -_-;
//	수정 일자	:	2003-07-25 오후 6:35 - 백상현, 2004년 11월 13일 추가 떡칠 임과장~
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
BOOL SOPlayer::CheckLaborHack( UI08 uiType, SI08 siStep, UI32 uiQuantity )
{
	if(siStep > 10)
	{
		if(pMyWorld->dwtimeGetTime > m_dwCondLaborTime)
		{
			if( (pMyWorld->dwtimeGetTime - m_dwCondLaborTime) < 1000 * 60 )
			{
				m_dwCondLaborTime = 0;
				return(FALSE);
			}
		}
		m_dwCondLaborTime = pMyWorld->dwtimeGetTime;
	}

	switch( uiType )
	{
	case MINIGAME_TYPE_1:
		return CheckLaborHack1( siStep, uiQuantity );		break;
	case MINIGAME_TYPE_2:
		return CheckLaborHack2( siStep, uiQuantity );		break;
	case MINIGAME_TYPE_3:
		return CheckLaborHack3( siStep, uiQuantity );		break;
	default:
		return FALSE;										break;
	}
}

/*
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	카드 짝 맞추기 일량 체크..
//	수정 일자	:	2003-07-25 오후 6:36 - 백상현
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
BOOL SOPlayer::CheckLaborHack1( SI08 siStep, UI32 uiQuantity )
{
	const UI32	uiCard[17]	=	{ 0, 12, 12, 16, 16, 18, 18, 24, 24, 30, 30, 24, 24, 32, 32, 40, 40 };	// 16단계

	// siStep 단계까지의 누적 포인트.. 0단계는 0
	UI32 uiPoint = 0;
	for( SI32 i = 1; i <= siStep; i++ )
	{
		uiPoint += uiCard[i] * 3 * uiCard[i] / 2;
	}
	UI32	uiMaxQuantity	=	uiPoint / 30;

	if( uiQuantity > uiMaxQuantity )	return FALSE;	// Hacked
	else								return TRUE;
}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	마작 일량 체크..
//	수정 일자	:	2003-07-25 오후 6:36 - 백상현
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
BOOL SOPlayer::CheckLaborHack2( SI08 siStep, UI32 uiQuantity )
{
	const UI32 uiCard[19] = { 0, 12, 12, 18, 18, 20, 20, 24, 24, 30, 30, 40, 40, 42, 42, 48, 48, 56, 56 };	// 18단계

	// siStep 단계까지의 누적 포인트.. 0단계는 0
	UI32 uiPoint = 0;
	for( SI32 i = 1; i <= siStep; i++ )
	{
		uiPoint += uiCard[i] * 4 * uiCard[i] / 3;
	}
	UI32	uiMaxQuantity	=	uiPoint / 75;

	if( uiQuantity > uiMaxQuantity )	return FALSE;	// Hacked
	else								return TRUE;
}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	과일 받기 일량 체크.. 하드 코딩의 진수 2탄 -_-;;
//	수정 일자	:	2003-07-25 오후 6:40 - 백상현
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
BOOL SOPlayer::CheckLaborHack3( SI08 siStep, UI32 uiQuantity )
{
	const UI32	uiNumFruit[11]	=	{ 0, 50, 50, 60, 60, 70, 70, 80, 80, 90, 90 };	// 10단계

	// siStep 단계까지의 누적 포인트.. 0단계는 0
	UI32 uiPoint = 0;
	for( SI32 i = 1; i <= siStep; i++ )
	{
		uiPoint += (i + 1) * uiNumFruit[i] + uiNumFruit[i] * (uiNumFruit[i] + 1 ) / 6;
	}
	UI32 uiMaxQuantity = uiPoint / 50;

	if( uiQuantity > uiMaxQuantity )	return FALSE;		// Hacked
	else								return TRUE;
}
*/


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	카드 짝 맞추기 일량 체크..
//	수정 일자	:	2003-07-25 오후 6:36 - 백상현
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
BOOL SOPlayer::CheckLaborHack1( SI08 siStep, UI32 uiQuantity )
{
#define MAX_CARD1 17
	const UI32	uiCard[MAX_CARD1]	=	{ 0, 12, 12, 16, 16, 18, 18, 24, 24, 30, 30, 24, 24, 32, 32, 40, 40 };	// 16단계

	if(siStep >= MAX_CARD1) return(FALSE);

	// siStep 단계까지의 누적 포인트.. 0단계는 0
	UI32 uiPoint = 0;
	for( SI32 i = 1; i <= siStep; i++ )
	{
		uiPoint += uiCard[i] * 3 * uiCard[i] / 2;
	}
	UI32	uiMaxQuantity	=	uiPoint / 30;

	if( uiQuantity > uiMaxQuantity )	return FALSE;	// Hacked
	else								return TRUE;
}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	마작 일량 체크..
//	수정 일자	:	2003-07-25 오후 6:36 - 백상현
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
BOOL SOPlayer::CheckLaborHack2( SI08 siStep, UI32 uiQuantity )
{
#define MAX_CARD2 19
	const UI32 uiCard[MAX_CARD2] = { 0, 12, 12, 18, 18, 20, 20, 24, 24, 30, 30, 40, 40, 42, 42, 48, 48, 56, 56 };	// 18단계

	if(siStep >= MAX_CARD2) return(FALSE);

	// siStep 단계까지의 누적 포인트.. 0단계는 0
	UI32 uiPoint = 0;
	for( SI32 i = 1; i <= siStep; i++ )
	{
		uiPoint += uiCard[i] * 4 * uiCard[i] / 3;
	}
	UI32	uiMaxQuantity	=	uiPoint / 75;

	if( uiQuantity > uiMaxQuantity )	return FALSE;	// Hacked
	else								return TRUE;
}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	과일 받기 일량 체크.. 하드 코딩의 진수 2탄 -_-;;
//	수정 일자	:	2003-07-25 오후 6:40 - 백상현
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
BOOL SOPlayer::CheckLaborHack3( SI08 siStep, UI32 uiQuantity )
{
#define MAX_CARD3 11
	const UI32	uiNumFruit[MAX_CARD3]	=	{ 0, 50, 50, 60, 60, 70, 70, 80, 80, 90, 90 };	// 10단계

	if(siStep >= MAX_CARD3) return(FALSE);

	// siStep 단계까지의 누적 포인트.. 0단계는 0
	UI32 uiPoint = 0;
	for( SI32 i = 1; i <= siStep; i++ )
	{
		uiPoint += (i + 1) * uiNumFruit[i] + uiNumFruit[i] * (uiNumFruit[i] + 1 ) / 6;
	}
	UI32 uiMaxQuantity = uiPoint / 50;

	if( uiQuantity > uiMaxQuantity )	return FALSE;		// Hacked
	else								return TRUE;
}




//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	공장의 정보를 요청했다.
//	수정 일자	:	2002-10-08 오후 2:15:04 - 양정모
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VOID	SOPlayer::RecvFarmWorkInfo()
{
	OnReqFarmWorkInfoMsg		*pFarmWorkInfoMsg;
	BOOL						bSuccess = FALSE;
	
	pFarmWorkInfoMsg		=	(OnReqFarmWorkInfoMsg*) cMsg;
	
	if( IsInVillage() == FALSE )										goto	END;
	
	bSuccess	=	stAccountInfo.pVillage->EnterIndustrialComplexFactory( this, SI32( pFarmWorkInfoMsg->uiSlotIndex ) );
		//bSuccess	=	stAccountInfo.pVillage->m_pIndustrialComplexs->SendFactoryInfo( this, pFarmWorkInfoMsg->uiSlotIndex );

			/*
		if(stAccountInfo.pStructure)
		{
			pFarmWorkInfoMsg		=	(OnReqFarmWorkInfoMsg*) cMsg;
			pFarmSlot	= stAccountInfo.pStructure->GetFarmSlot(pFarmWorkInfoMsg->uiSlotIndex);
			if(pFarmSlot)
			{
				if( pFarmSlot->bOnSchedule() )
				{
					SendFieldMsg(ON_RESPONSE_FARM_WORKINFO, SO_SFM_ONLYME, LPVOID(ON_RET_OK), LPVOID(pFarmSlot));
					return;
				}
				else if( pFarmSlot->bStore )
				{
					if( stAccountInfo.pVillage->IsFarmOwner( this ) )
					{
						SendFieldMsg(ON_RESPONSE_STORAGE_INFO, SO_SFM_ONLYME, LPVOID(ON_RET_OK),LPVOID(pFarmSlot));
						return;
					}
				}
			}
		}
	
	}
	*/
END:

	if( bSuccess == FALSE )
	{
		SendFieldMsg(ON_RESPONSE_FARM_WORKINFO, SO_SFM_ONLYME, LPVOID(ON_RET_NO));
	}

}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	창고에 있는 아이템을 보낸다.
//	수정 일자	:	2002-10-08 오후 3:13:24 - 양정모
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VOID	SOPlayer::RecvStorageInfo()
{
	OnReqStorageInfoMsg				*pStorageInfoMsg;
	BOOL							bSuccess = FALSE;

	pStorageInfoMsg				=	(OnReqStorageInfoMsg*)	cMsg;		

	if( IsInVillage() == FALSE )									goto	END;

	bSuccess	=	stAccountInfo.pVillage->EnterIndustrialComplexFactory( this, SI32( pStorageInfoMsg->uiSlotIndex ) );
		/*
		if(stAccountInfo.pStructure)
		{
			pStorageInfoMsg				=	(OnReqStorageInfoMsg*)	cMsg;
			pFarmSlot	=	stAccountInfo.pStructure->GetFarmSlot(pStorageInfoMsg->uiSlotIndex);
			if(pFarmSlot)
			{
				if(pFarmSlot->bStore)
				{
					if( pFarmSlot->bOnSchedule() )
					{
						SendFieldMsg( ON_RESPONSE_FARM_WORKINFO, SO_SFM_ONLYME, LPVOID(ON_RET_OK),LPVOID(pFarmSlot));
						return;
					}
					else
					{
						if(stAccountInfo.pVillage->IsFarmOwner(this))
						{
							SendFieldMsg( ON_RESPONSE_STORAGE_INFO, SO_SFM_ONLYME, LPVOID(ON_RET_OK), LPVOID(pFarmSlot));
							return;
						}
					}
				}
			}
		}
		*/
	
END:

	if( bSuccess == FALSE )
	{

		SendFieldMsg(ON_RESPONSE_STORAGE_INFO, SO_SFM_ONLYME, LPVOID(ON_RET_NO));

	}

}

//----------------------------------------------------------------------------------------------------------------
//	설명	:	창고에 있는 아이템을 넣는다.
//----------------------------------------------------------------------------------------------------------------
VOID	SOPlayer::RecvStorageInputItem()
{
	OnReqStorageInputItemMsg				*pStorageInputItemMsg;
	BOOL									bSuccess = FALSE;

	SI32 FarmID = -1;
	SI32 FactoryID = -1;
	SI32 FactorySlot = -1;

	SI32 InvenSlot;
	

	if( IsInVillage() == FALSE )			goto	END;		

	pStorageInputItemMsg		=	(OnReqStorageInputItemMsg*) cMsg;

	// 해당 용병이 아이템을 가지고 있는지 검사한다.
	if( IFollower.HasItem( pStorageInputItemMsg->uiFollowerID, pStorageInputItemMsg->uiItemCode, UI16( pStorageInputItemMsg->uiQunatity ) ) == FALSE )	goto	END;

	InvenSlot = IFollower.GetItemIndex(pStorageInputItemMsg->uiFollowerID, pStorageInputItemMsg->uiItemCode);

	

	if( stAccountInfo.pVillage->StorageInputItem( this, pStorageInputItemMsg->uiItemCode, pStorageInputItemMsg->uiQunatity ) == FALSE )						goto	END;

	// 최악의 코드등장!
	// db query에 쓰기위해 아이템이 저장된 슬롯을 얻어온다.
	FarmID = stAccountInfo.pVillage->m_pIndustrialComplexs->GetEnteredIndustrialComplexIndex(this);

	if ( FarmID != -1) {
		FactoryID = stAccountInfo.pVillage->m_pIndustrialComplexs->GetEnteredIndustrialComplex(this)->GetEnteredFactoryIndex(this);

		if (FactoryID != -1) {
			stAccountInfo.pVillage->m_pIndustrialComplexs->GetEnteredIndustrialComplex(this)->GetEnteredFactory(this)->GetItem(pStorageInputItemMsg->uiItemCode,&FactorySlot);
			if (FactorySlot == -1)
			{
				goto END;
			}

		}
		else
		{
			goto END;
		}
	}
	else
	{
		goto END;
	}
	
	// 해당 용병의 아이템을 뺀다.
	DelItemNoQuery( pStorageInputItemMsg->uiFollowerID, pStorageInputItemMsg->uiItemCode, pStorageInputItemMsg->uiQunatity );		

	bSuccess	=	TRUE;

	


END:

	if( bSuccess == FALSE )
	{

		SendFieldMsg( ON_RESPONSE_STORAGE_INPUTITEM, SO_SFM_ONLYME, LPVOID( ON_RET_NO ) );
	}
	else
	{

		DBIKStorageInputItem  info;
		info.DBAccount = this->stAccountInfo.siDBAccount;
		info.uiSlot = this->stAccountInfo.uiSlot;		

		info.uiVillageCode = stAccountInfo.pVillage->uiVillageCode;
		info.uiFarmID = FarmID;
		info.uiFactoryID = FactoryID;

		info.uiItemCode = pStorageInputItemMsg->uiItemCode;
		info.uiItemQnt = pStorageInputItemMsg->uiQunatity;
		info.uiMercenary = pStorageInputItemMsg->uiFollowerID;
		info.uiMercenaryItemPosition = InvenSlot;

		info.uiStoreItemPosition = FactorySlot;

		
		pMyWorld->clDatabase->writeDBQuery(SO_DB_INFOKIND_FARM_STORAGE_INPUT_ITEM,&info,sizeof(info));


		SendFieldMsg( ON_RESPONSE_STORAGE_INPUTITEM, SO_SFM_ONLYME, LPVOID( ON_RET_OK ) );
	}
}

//----------------------------------------------------------------------------------------------------------------
//	설명	:	창고서 아이템을 꺼낸다.
//----------------------------------------------------------------------------------------------------------------
VOID	SOPlayer::RecvStorageOutputItem()
{
	OnReqStorageOutputItemMsg				*pStorageOutputItemMsg;
	UI32									uiTemp=0;
	BOOL									bSuccess = FALSE;

	SI32 FarmID = -1;
	SI32 FactoryID = -1;
	SI32 FactorySlot = -1;

	SI32 InvenSlot;
	

	if( IsInVillage() == FALSE )			goto	END;		
	
	pStorageOutputItemMsg		=	(OnReqStorageOutputItemMsg*) cMsg;

	// 해당 용병에게 아이템을 넣을 수 있는지 검사한다.
	if( IFollower.CanAddItem( pStorageOutputItemMsg->uiFollowerID, pStorageOutputItemMsg->uiItemCode, UI16( pStorageOutputItemMsg->uiQunatity ) ) == FALSE )	goto	END;

	

	// 최악의 코드 또 등장!
	// 이번에는 아이템을 꺼내기전에 미리 위치를 확인한다.
	FarmID = stAccountInfo.pVillage->m_pIndustrialComplexs->GetEnteredIndustrialComplexIndex(this);

	if (FarmID != -1) {
		FactoryID = stAccountInfo.pVillage->m_pIndustrialComplexs->GetEnteredIndustrialComplex(this)->GetEnteredFactoryIndex(this);
		if (FactoryID != -1) {
			stAccountInfo.pVillage->m_pIndustrialComplexs->GetEnteredIndustrialComplex(this)->GetEnteredFactory(this)->GetItem(pStorageOutputItemMsg->uiItemCode,&FactorySlot);
			if (FactorySlot == -1)
			{
				goto END;
			}
		}
		else
		{
			goto	END;
		}
	}
	else
	{
		goto	END;

	}
	
	

	if( stAccountInfo.pVillage->StorageOutputItem( this, pStorageOutputItemMsg->uiItemCode, pStorageOutputItemMsg->uiQunatity ) == FALSE )						goto	END;

	// 해당 용병의 아이템을 더한다.
	AddItemNoQuery( pStorageOutputItemMsg->uiFollowerID, pStorageOutputItemMsg->uiItemCode, pStorageOutputItemMsg->uiQunatity );

	// 아이템을 넣고나서 들어간 위치를 확인한다.
	InvenSlot = IFollower.GetItemIndex(pStorageOutputItemMsg->uiFollowerID, pStorageOutputItemMsg->uiItemCode);
	

	bSuccess	=	TRUE;
		
/*		if(stAccountInfo.pVillage->StorageOutputItem( pStorageOutputItemMsg->uiPlantID,pStorageOutputItemMsg->uiPartID,
			pStorageOutputItemMsg->uiSlotIndex,pStorageOutputItemMsg->uiItemCode, pStorageOutputItemMsg->uiQunatity) != 0)
		{			
			AddItem(pStorageOutputItemMsg->uiFollowerID, pStorageOutputItemMsg->uiItemCode, pStorageOutputItemMsg->uiQunatity,pStorageOutputItemMsg->siPosInInventory);
			SendFieldMsg(ON_RESPONSE_STORAGE_OUTPUTITEM, SO_SFM_ONLYME, LPVOID(ON_RET_OK));
			return;
		}
		*/
	
END:

	if( bSuccess == FALSE )
	{

		SendFieldMsg(ON_RESPONSE_STORAGE_OUTPUTITEM, SO_SFM_ONLYME, LPVOID(ON_RET_NO));

	}
	else
	{

		DBIKStorageOutputItem  info;

		info.DBAccount = stAccountInfo.siDBAccount;
		info.uiSlot = stAccountInfo.uiSlot;		

		info.uiVillageCode = stAccountInfo.pVillage->uiVillageCode;
		info.uiFarmID = FarmID;
		info.uiFactoryID = FactoryID;

		info.uiItemCode = pStorageOutputItemMsg->uiItemCode;
		info.uiItemQnt = pStorageOutputItemMsg->uiQunatity;
		info.uiMercenary = pStorageOutputItemMsg->uiFollowerID;
		info.uiMercenaryItemPosition = InvenSlot;

		info.uiStoreItemPosition = FactorySlot;

		
		pMyWorld->clDatabase->writeDBQuery(SO_DB_INFOKIND_FARM_STORAGE_OUTPUT_ITEM,&info,sizeof(info));

		SendFieldMsg(ON_RESPONSE_STORAGE_OUTPUTITEM, SO_SFM_ONLYME, LPVOID(ON_RET_OK));

	}
}


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	임금을 바꾼다.
//	수정 일자	:	2002-07-24 오전 11:37:15 - 양정모
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VOID	SOPlayer::RecvPlantChangPay()
{
	OnReqPlantChangePayMsg					*pPlantChangePayMsg;
	DWORD									dwResult= ON_RET_NO;
	BOOL									bSuccess = FALSE;
	
	if(stAccountInfo.pVillage != NULL)
	{
		pPlantChangePayMsg		=	(OnReqPlantChangePayMsg*) cMsg;
	
		bSuccess				=	stAccountInfo.pVillage->ChangePay( this, pPlantChangePayMsg->uiSlotIndex, pPlantChangePayMsg->siPay );		

		//dwResult				=	stAccountInfo.pVillage->ChangePay(this, pPlantChangePayMsg->uiSlotIndex, pPlantChangePayMsg->siPay);		
	}
	
	// 임금을 바꾸면서 얻는 이익을 보내준다.
	if( bSuccess == FALSE )
	{
		//SendFieldMsg(ON_RESPONSE_PLANT_CHANGE_PAY, SO_SFM_ONLYME, LPVOID(dwResult),LPVOID(&siMoney));
		SendFieldMsg(ON_RESPONSE_PLANT_CHANGE_PAY, SO_SFM_ONLYME, LPVOID( ON_RET_NO ) );
	}

	
}

//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
//	설명		:	작업을 취소한다.
//	수정 일자	:	2002-10-12 오후 2:36:44 - 양정모
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
VOID	SOPlayer::RecvPlantCancelPlan()
{
	OnReqPlantCancelPlanMsg					*pPlantChangePayMsg;
	BOOL									bSuccess = FALSE;	
	
	pPlantChangePayMsg			=	(OnReqPlantCancelPlanMsg*) cMsg;

	if( IsInVillage() == FALSE )									goto	END;
	
	bSuccess		=	stAccountInfo.pVillage->CancelWork( this, SI32( pPlantChangePayMsg->uiSlotIndex ) );

END:

	if( bSuccess == FALSE )
	{

		SendFieldMsg( ON_RESPONSE_PLANT_CANCEL_PLAN, SO_SFM_ONLYME, LPVOID( ON_RET_NO ) );

	}
}


